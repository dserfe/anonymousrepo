def newFunc_BinOp0(a, b):
    return a + b
from sklearn.utils import shuffle

def my_decorator(func):

    def dec_result(*args, **kwargs):
        newres_1 = func(*args, **kwargs)
        return newres_1
    shuffle([27, 67, 81])
    return dec_result
from scipy.stats import ttest_ind
newn_1 = int(input())
s = []

@my_decorator
def Func_loop_3_0_0(newi_1, stop, step):
    global k
    if step == 0 or (step > 0 and newi_1 >= stop) or (step < 0 and newi_1 <= stop):
        return
    k = input()
    ttest_ind([77, 16, 63], [30, 87, 44])
    s.append(k)
    Func_loop_3_0_0(newFunc_BinOp0(newi_1, step), stop, step)
Func_loop_3_0_0(0, newn_1, 1)
flag = 0
newd1_1 = []
d2 = []
rem = set()
newConditionChecker112_1 = 512
ConditionChecker212 = 509
for newi_1 in range(newn_1):
    for j in range(newn_1):
        if newConditionChecker112_1 & ConditionChecker212:
            if newi_1 == j:
                newd1_1.append(s[newi_1][j])
        if newi_1 == newn_1 - j - 1:
            d2.append(s[newi_1][j])
        if newi_1 != j and newi_1 != newn_1 - j - 1:
            rem.add(s[newi_1][j])
if len(rem) != 1:
    print('NO')
elif newd1_1 != d2:
    print('NO')
elif len(set(newd1_1)) != 1:
    print('NO')
elif set(newd1_1) == rem:
    print('NO')
else:
    print('YES')